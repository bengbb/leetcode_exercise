int firstBadVersion(int n) {
int i = 0;
while(!isBadVersion(i))
    i++;
    return i;
}
//直接暴力解法，把所有的情况便利一遍
  时复o（n）

    //采用二分查找
int firstBadVersion(int n) {
    int left = 1 , right = n;
    while(left<right){//当left==right时出循环，则left就是答案
        int mid = left+(right - left)/2;//计算中点，避免 (left + right) / 2 可能导致的整数溢出。例如：left = 1.5e9, right = 2e9 → left + right 超过 INT_MAX  left + (right - left)/2 是安全写法 ✅
        if(isBadVersion(mid))right = mid;//mid 可能是第一个坏版本，不能跳过
        else left = mid + 1;// mid 是好版本，第一个坏版本一定在右边
    }
    return left;
}
  
