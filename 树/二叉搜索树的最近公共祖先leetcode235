给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

我的解法（略微有点问题）   递归调用时没有 return，导致函数可能返回 0（即 NULL），从而得到错误结果。
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if(p->val < root->val && q->val < root->val)
     lowestCommonAncestor(root->left,p,q);
    else if(p->val > root->val && q->val > root->val)
     lowestCommonAncestor(root->right,p,q);
      else if(p->val == root->val || q->val == root->val || (p->val < root->val && q->val > root->val))
      return root;
      return NULL; // 如果走上面两个分支，最终会执行到这里，返回 NULL！
}
采用递归算法时复o（h）空复o（h）

简洁版
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (p->val < root->val && q->val < root->val)
        return lowestCommonAncestor(root->left, p, q);
    if (p->val > root->val && q->val > root->val)
        return lowestCommonAncestor(root->right, p, q);
    return root;
}
但是没有在时复和空复上改进
