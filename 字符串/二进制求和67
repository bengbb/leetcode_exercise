我的解法（错误）
void change(char*a , char*b){//❌ 问题 1：change 函数逻辑完全错误
    int m = strlen(a),n = strlen(b);
    if(m<n){
        for(int i = 0 ; i < n-m ; i++)
        a[i]=0;//a[i] = 0 不是补前导零！二进制加法需要 在前面补零（高位补零），比如 "11" 和 "1" → "11" 和 "01"
    }
    else if(n<m){
        for(int i = 0 ; i < m-n ; i++)
        b[i]=0;
    }
}
char* addBinary(char* a, char* b) {
    change(a,b);
    int m = strlen(a),n = strlen(b);
    char* ans = (char*)malloc(sizeof(char)*(m+1));
    int i = m - 1 , k = n - 1 , j = m;
    int count = 0;
    while(j>0){
        if( a[i] + b[k] == 1){//❌ 问题 2：字符 '0'/'1' 被当作数字 0/1 使用
            ans[j] = 1 ;
            if(count == 1){
                ans[j]++;
                count = 0;
            }
            i--;k--;j--;
        }
       else if( a[i] + b[k] == 0){
            ans[j] = 0;
            if(count == 1){
                ans[j]++;
                count = 0;
            }
            i--;k--;j--;
        }
       else if( a[i] + b[k] == 2 ){
        ans[j] = 0;
        count++;
        j--;i--;k--;//❌ 问题 5：进位处理不完整如果有进位 + 1+1，可能产生 进位传递（如 1+1+1=3 → 写1，进1）
       }
    }
    if(count != 0)
    ans[0] = 1;
    return ans; 
}

解答
char* addBinary(char* a, char* b) {
    int lenA = strlen(a) , lenB = strlen(b);
    int Maxlen = (lenA > lenB ? lenA:lenB);
    char* ans = (char*)malloc(sizeof(char)*(Maxlen + 2)); // 分配足够空间：maxLen + 1（进位）+ 1（\0）
    int i = lenA - 1 , j = lenB - 1 , k = Maxlen + 1 , count = 0;
    ans[k--] = '\0' ; // 从最后开始填（留位置给 \0）
    while( i>=0 || j>=0 || count ){
        int sum = count;
        if( i >= 0 )sum += a[i--] - '0';
        if( j >= 0 )sum += b[j--] - '0';
        ans[k--] = (sum %2) + '0';
        count = sum/2;
    }
    return ans+k+1;//是 C 语言中动态构建字符串时常用的“指针偏移”技巧，目的是 跳过前面未使用的内存空间，返回真正字符串的起始地址。
}


