摩尔投票法
int majorityElement(int* nums, int numsSize) {
    int candidate = nums[0];
    int count = 1;
    for(int i = 0 ; i < numsSize ; i++ ){
        if(nums[i] == candidate )
        count++;// 同一阵营，+1
        else count--;
        if(count == 0){
        candidate = nums[i];
        count = 1;
        }
    }
    return candidate;
}
🧠 核心思想：“同归于尽”抵消法
想象一场 阵营对战：
众数（majority）是一个超级大阵营，人数 > 总人数的一半
其他所有数合起来 < 一半
💥 抵消规则：
每次从数组中取出两个不同的元素，把它们都“消灭”
重复这个过程，直到无法继续
❓ 最后剩下的是什么？
一定是众数！
因为：
众数数量 > 其他所有数之和
即使其他所有数都用来和众数“一对一换命”，众数也还有剩！
为什么换选没有危险
  当你看到 某一段战斗结束后，战场上尸横遍野，但没有活人了（即 count == 0），这意味着：
在这段区间里，所有阵营人数相等（或互相抵消干净），没有任何一方占优。
那么：
真正的“超级大阵营”（众数）如果存在，一定不在这个已结束的区间里占多数
它的主要力量一定在后面的未处理部分
所以你可以完全忽略前面这段，从下一个人开始重新观察！
✅ 这就是“换候选安全”的本质。
